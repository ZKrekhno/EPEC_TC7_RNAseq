---
title: "RUV-seq on short infection"
output: 
  html_notebook: 
    fig_width: 6
    fig_height: 5
editor_options: 
  chunk_output_type: inline
---

```{r include=TRUE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(include = TRUE)
knitr::opts_chunk$set(fig.width = 6)
knitr::opts_chunk$set(fig.height = 5)
library(greekLetters)
library(RUVSeq)
library(EDASeq)
library(DESeq2)
library(PCAtools)
library(limma)
library(pheatmap)
library(eulerr)
library(tidyverse)
library(ggprism)
library(rcartocolor)
```

Define all helper functions and color choices
```{r include=TRUE}
theme_set(theme_prism(base_size = 14))
#Set color choices from CARTOcolors
discrete_pal_choice <- "Bold"
cont_pal_choice <- "BluYl"
diverg_pal_choice <- "Geyser"
#Helper functions
calc_relative <- function(x) x/sum(x) * 100
#Set up paths for data, and results
data_path <- "short_infection_human_reads/data/"
res_path <- "short_infection_human_reads/results/"

```

```{r readorigstar}
counts <- read.table(here::here(str_c(data_path,"STAR_reads_updated.txt")),header = F, sep = "\t", stringsAsFactors = F)
#Next manipulate the table to remove redundant columns and only keep relevant columns (1 columns with gene names, and the rest with counts for reverse stranded library
counts_simple <- counts [,seq(from=4,to=96,by=4)]
colnames(counts_simple) <- c("4UIN", "4UIWT", "490WT", "490N", "4180N", "4180WT", "5UIN", "5UIWT", "545WT", "545N", "590WT", "590N", "5180N", "5180WT", "6UIN", "6UIWT", "645WT", "645N", "690WT", "690N", "6180N", "6180WT", "445N", "445WT")
#Prior analysis revealed that 6UIN is an outlier by PCA plot
counts_simple <- counts_simple %>% 
  dplyr::select(-`6UIN`)
counts_simple$Gene_ID <- counts$V1

filter <- apply(dplyr::select(counts_simple,-Gene_ID),1,function(x) mean(x)>5)
counts_simple <- counts_simple [filter,]
```

Apply EDAseq normalization to the data

```{r edaseq}
#Use EDAseq to normalize the libraries
c_mat <- counts_simple %>% 
                     dplyr::select(-dplyr::last_col()) %>% 
                     dplyr::slice(-1:-4) %>% 
                     as.matrix()
rownames(c_mat) <- counts_simple$Gene_ID [-1:-4]
pData <- data.frame(genotype=vector(mode = "logical", length = ncol(c_mat)),
                    timepoint = vector(mode = "logical", length = ncol(c_mat)),
                    samples = colnames(c_mat),
                    row.names = colnames(c_mat))
pData <- pData %>% 
  mutate(genotype = case_when(
    str_detect(samples, "WT") ~ "WT",
    str_detect(samples, "UIN") ~ "WT",
    str_detect(samples, "N") ~ "N"
  ), timepoint = case_when(
    str_detect(samples, "UI") ~ 0,
    str_detect(samples, "45") ~ 45,
    str_detect(samples, "90") ~ 90,
    str_detect(samples, "180") ~ 180,
  ), group = str_c(genotype,timepoint,sep = ""),
  graph_cols = case_when(
    str_detect(samples, "UI") ~ carto_pal(n=6, cont_pal_choice) [2],
    str_detect(samples, "45") ~ carto_pal(n=6, cont_pal_choice) [4],
    str_detect(samples, "90") ~ carto_pal(n=6, cont_pal_choice) [5],
    str_detect(samples, "180") ~ carto_pal(n=6, cont_pal_choice) [6])) %>% 
  dplyr::select(-samples)

data <- newSeqExpressionSet(counts=c_mat,
                            phenoData=pData)
#Normalize the data next
dataNorm <- betweenLaneNormalization(data, which="upper") 
#For DE we will create this analysis with offset values
dataOffset <- betweenLaneNormalization(data,
                                       which="upper",offset=TRUE)
#Plot the counts 
#pdf(here::here(str_c(res_path,"final RUV figures/Normalization effect on the library.pdf")), width = 8, height = 6)
graph_cols <- pData$graph_cols
plotPCA(data, col = graph_cols, main = "Unnormalized counts")
plotPCA(dataOffset, col = graph_cols, main = "Normalized counts")
plotRLE(data, col = graph_cols, main = "RLE Unnormalized counts")
plotRLE(dataOffset, col = graph_cols, main = "RLE Normalized counts")
boxplot(data, main = "Unnormalized counts", col = graph_cols)
boxplot(dataNorm, main = "Normalized counts", col = graph_cols)
#dev.off()
```



Try RUV-Seq. First confirm that library size normalization helps somewhat with data, but not enough for clear separation of genotypes

Prepare the RUV-seq objects and perform RUVs normalization. Only testing the effects of this with 90 or 180 min, since 45 min would be too short to expect T3SS differences
``` {r ruv-start, echo=TRUE, results = 'asis', include=TRUE}
scidx <- matrix(data = -1,  nrow = 5, ncol = 5)
scidx [1,] <- str_subset(rownames(pData),"UI")
scidx [2,1:3] <- str_subset(rownames(pData),"90WT")
scidx [3,1:3] <- str_subset(rownames(pData),"90N")
scidx [4,1:3] <- str_subset(rownames(pData),"180WT")
scidx [5,1:3] <- str_subset(rownames(pData),"180N")
cidx <- rownames(counts(data))
data_no45 <- newSeqExpressionSet(counts=c_mat [, str_detect(colnames(c_mat), "45", negate = T)],
                            phenoData=filter(pData, timepoint != 45))
dataOffset_no45 <- betweenLaneNormalization(data_no45,
                                       which="upper",offset=TRUE)
rv1 <- RUVs(dataOffset_no45, cidx, k=1, scidx, epsilon = 1, isLog = F)
rv2 <- RUVs(dataOffset_no45, cidx, k=2, scidx, epsilon = 1, isLog = F)
#pdf(here::here(str_c(res_path,"final RUV figures/Normalization effect on the library and RUV normalization.pdf")), width = 8, height = 6)
graph_cols <- pull(filter(pData, timepoint != 45),graph_cols)
plotPCA(dataOffset_no45, col = graph_cols, main = "Upper (method) normalized counts")
plotPCA(rv1, col = graph_cols, main = "Upper (method) normalized counts + RUVs with 1 k")
plotPCA(rv2, col = graph_cols, main = "Upper (method) normalized counts + RUVs with 2 k")
plotRLE(dataOffset, col = graph_cols, main = "Upper (method) normalized counts")
plotRLE(rv1, col = graph_cols, main = "Upper (method) normalized counts + RUVs with 1 k")
plotRLE(rv2, col = graph_cols, main = "Upper (method) normalized counts + RUVs with 2 k")
#dev.off()
```
#The RUV normalization is done, now we have normalization factors or weights, that can be fed into DESeq2
Keep an eye on this 
https://bioconductor.org/packages/release/workflows/vignettes/rnaseqGene/inst/doc/rnaseqGene.html#using-ruv-with-deseq2


``` {r de_test, echo=TRUE, results = 'asis', include=TRUE}
dds <- DESeqDataSetFromMatrix(countData = counts(dataOffset_no45),
                              colData = pData(dataOffset_no45),
                              design = ~  group)
dds$group <- relevel(dds$group, ref = "WT0")
normFactors <- exp(-1 * offst(dataOffset_no45))
normFactors <- normFactors / exp(rowMeans(log(normFactors)))
normalizationFactors(dds) <- normFactors
dds <- DESeq(dds)
rld <- vst(dds)
DESeq2::plotPCA(rld, intgroup = "group")
resWTvsN <- results(dds, contrast = c("group","WT180", "N180"))
resWTvsUI <- results(dds, contrast = c("group","WT180", "WT0"))
walk(list(resWTvsUI,resWTvsN),summary)


dds1 <- DESeqDataSetFromMatrix(countData = counts(rv1),
                              colData = pData(rv1),
                              design = ~ W_1 + group)
normFactors <- exp(-1 * offst(dataOffset_no45))
normFactors <- normFactors / exp(rowMeans(log(normFactors)))
normalizationFactors(dds1) <- normFactors
dds1 <- DESeq(dds1)
rld1 <- vst(dds1)
DESeq2::plotPCA(rld1, returnData = F, intgroup = "group")

mat <- limma::removeBatchEffect(assay(rld1),
                                covariates = rld1$W_1, design = model.matrix(~ genotype, colData(rld1)))
rld1.nobatch <- rld1
assay(rld1.nobatch) <- mat
DESeq2::plotPCA(rld1.nobatch, returnData = F, intgroup = "group")

resWTvsN.1 <- results(dds1, contrast = c("group","WT180", "N180"))
resWTvsUI.1 <- results(dds1, contrast = c("group","WT180", "WT0"))
walk(list(resWTvsUI.1,resWTvsN.1),summary)

#Now repeat with 2 factors accounted for:
dds2 <- DESeqDataSetFromMatrix(countData = counts(rv2),
                              colData = pData(rv2),
                              design = ~ W_1 + W_2 + group)
normalizationFactors(dds2) <- normFactors
dds2 <- DESeq(dds2)
rld2 <- vst(dds2)
DESeq2::plotPCA(rld2, returnData = F, intgroup = "group")

mat <- limma::removeBatchEffect(assay(rld2),
                                covariates = matrix(data = c(rld2$W_1,rld2$W_2), ncol = 2),
                                design = model.matrix(~ genotype, colData(rld2)))
rld2.nobatch <- rld2
assay(rld2.nobatch) <- mat
DESeq2::plotPCA(rld2.nobatch, returnData = F, intgroup = "group")

resWTvsN.2 <- results(dds2, contrast = c("group","WT180", "N180"))
resWTvsUI.2 <- results(dds2, contrast = c("group","WT180", "WT0"))
walk(list(resWTvsUI.2,resWTvsN.2),summary)
```

Generally, the differences between 1 and 2 factors are not that large. No comparisons uncover DE genes between WT and T3SS-mutant infected cells.
Check how differentially expressed genes behave
```{r euler_wt_ui_de}
wtvsn.res <- list(resWTvsUI, resWTvsUI.1,resWTvsUI.2) %>% 
  map(as.data.frame) %>%  
  map(~(filter(.,padj < 0.05))) %>% 
  map(function(x) rownames(x))
names(wtvsn.res) <- c("No RUV","RUVs k=1","RUVs k=2")
#Visualize these results on a Venn diagram
#pdf(here::here(str_c(res_path,"final RUV figures/RUV effect on DE genes between WT and and 0min infection.pdf")), width = 8, height = 6)
eulerplot <- euler(wtvsn.res, shape = "circle")
plot(eulerplot, quantities = list(T, type = c("counts"), fontsize = 12), 
     fills = c(carto_pal(7,"BluYl") [1],carto_pal(7,"BluYl") [3], carto_pal(7,"BluYl") [7]),
     adjust_labels = T, alpha = 0.7, legend = T, labels = F)
plot(eulerplot, quantities = list(T, type = c("counts", "percent"), fontsize = 12), 
     fills = c(carto_pal(7,"BluYl") [1],carto_pal(7,"BluYl") [3], carto_pal(7,"BluYl") [7]),
     adjust_labels = T, alpha = 0.7, legend = T, labels = F)
#dev.off()
```

From this it is not clear that RUVs is very helpful in with this library prep. Keep it just to EDAseq normalization. Just do final confirmation that there is not much change in association between PC components and metadata
```{r linear_regression_pca, fig.width=8, fig.height=6}
p_list <- set_names(list(rld,rld1.nobatch,rld2.nobatch), nm = c("No RUV", "RUVs k=1", "RUVs k=2")) %>% 
  map(~pca(assay(.x), colData(.x), removeVar = 0.1))
pca_coord_meta_list <- p_list %>% 
  map(~.x$rotated) %>% 
  map2(list(rld,rld1.nobatch,rld2.nobatch), ~merge(.x,as.data.frame(colData(.y)), by = 0)) %>% 
  map(mutate, 
      group = fct_relevel(group, "WT0"),
      timepoint = as.numeric(timepoint),
      genotype = fct_relevel(genotype, "N"),)
#Create the lists to store information on the linear model performance
fit_list <- p_list
signi_list <- p_list
#Run the linear model for each PC - only first 9
for (i in seq_along(pca_coord_meta_list)) {
  pca_coord_meta_df <- pca_coord_meta_list [[i]]
  #Create a fit for each PC
  fit_list [[i]] <- set_names(vector(mode = "list", length = 9),
                              nm = str_c("PC",1:9))
  signi_list [[i]] <- set_names(vector(mode = "list", length = 9),
                                nm = str_c("PC",1:9))
  for (PC in seq_along(fit_list [[i]])) {
    fit_list [[i]] [[PC]] <- set_names(vector(mode = "list", length = 3),
                              nm = c("group", "timepoint", "genotype"))
    signi_list [[i]] [[PC]] <- set_names(vector(mode = "list", length = 3),
                              nm = c("group", "timepoint", "genotype"))
    for (metavar in c("group", "timepoint", "genotype")) {
      frm <- as.formula(str_c("PC",PC, " ~ ", metavar))
      fit_list [[i]] [[PC]] [[metavar]] <- lm(frm, data = pca_coord_meta_df)
      sum_of_fit <- summary(fit_list [[i]] [[PC]] [[metavar]])
      signi_list [[i]] [[PC]] [[metavar]] <- sum_of_fit$coefficients %>% 
        as.data.frame() %>% 
        mutate(R_squared = sum_of_fit$r.squared,
               PC = str_c("PC",PC),
               metavar = metavar) %>% 
        rownames_to_column(var = "coef")
    }
  }
}
#Summarise liner model performance and plot the results
signi_list_reduced <- signi_list %>% 
  map_depth(2,reduce,bind_rows) %>% 
  map_depth(1, reduce,bind_rows) %>% 
  map2(names(signi_list), ~mutate(.x, RUV = .y)) %>% 
  purrr::reduce(bind_rows) %>% 
  filter(coef != "(Intercept)") %>% 
  dplyr::rename(p = `Pr(>|t|)`) %>%  
  mutate(signi = case_when(
    p < 0.05 ~ "yes",
    TRUE ~ "no"
  ))
#Plot the results of regression
ggplot(signi_list_reduced) +
  geom_tile(aes(y=coef,x=PC, fill = p)) +
  geom_text(data = filter(signi_list_reduced, signi == "yes"), aes(y=coef,x=PC), 
            label = "*", color = "white", size = 7, nudge_y = -0.02) +
  facet_wrap(~RUV, nrow = 3, scales = "free") +
  labs(x = element_blank(), y = element_blank(), title = "Linear regression analysis\nidentifying relationships between metadata and PC") +
  scale_y_discrete(labels = c(timepoint = "Time of Infection",
                              genotypeWT = "Effect of T3SS",
                              groupWT90 = "Effect of WT EPEC at 90 min",
                              groupWT180 = "Effect of WT EPEC at 180 min",
                              groupN90 = bquote("Effect of" ~ Delta*"EscN EPEC at 90 min"),
                              groupN180 = bquote("Effect of" ~ Delta*"EscN EPEC at 180 min"))) +
  scale_fill_carto_c(palette = "BluYl", direction = -1, name = "p-value") +
  theme_minimal(base_size = 16) +
  theme(panel.border = element_rect(fill = NA, color = "black"),
        axis.ticks.x = element_line(color = "black"),
        axis.ticks.y = element_line(color = "black"),
        panel.grid.major = element_blank(),
        axis.text = element_text(color = "black"),
        title = element_text(size = 12),
        legend.title = element_text(size = 19))
#ggsave(here::here(str_c(res_path,"final RUV figures/Linear regression of metadata and PCA with respect to RUV.png")), width = 8,height = 6, dpi = 1080)
#Shifting correlations from PC2 to PC1 does not change much, as PC1 and PC2 explain about similar amounts of variation
#pdf(here::here(str_c(res_path,"final RUV figures/screeplots for each RUV approach.pdf")), width = 6, height = 5)
walk2(p_list, names(p_list),
      ~print(screeplot(.x, title = .y, colBar = carto_pal(2,cont_pal_choice) [2])))
#dev.off()
```

