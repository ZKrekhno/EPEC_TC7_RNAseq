---
title: "Finalized analysis of EPEC reads in Polarized infection"
output: 
  html_notebook:
    fig_width: 6
    fig_height: 5
editor_options: 
  chunk_output_type: inline
---

```{r lib-setup, results='hide', message=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(include = TRUE)
knitr::opts_chunk$set(fig.width = 6)
knitr::opts_chunk$set(fig.height = 5)
library(greekLetters)
library(RUVSeq)
library(EDASeq)
library(DESeq2)
library(PCAtools)
library(limma)
library(pheatmap)
library(eulerr)
library(clusterProfiler)
library(tidyverse)
library(ggprism)
library(rcartocolor)
library(patchwork)
```

Define all helper functions and color choices
```{r helper, include=TRUE}
theme_set(theme_prism(base_size = 14) + theme(legend.title = element_text()))
#Set color choices from CARTOcolors
discrete_pal_choice <- "Bold"
cont_pal_choice <- "BluYl"
diverg_pal_choice <- "Geyser"
#Helper functions
calc_relative <- function(x) x/sum(x) * 100
#Set up paths for data, and results
data_path <- "long_infection_EPEC_reads/data/"
res_path <- "long_infection_EPEC_reads/results/"
```

#Read in the count data and rename the columns to fit the sample names

```{r readorigstar}
counts <- read.table(here::here(str_c(data_path,"all_EPEC_reads_STAR.txt")),header = F, sep = "\t", stringsAsFactors = F)
#Next manipulate the table to remove redundant columns and only keep relevant columns (1 columns with gene names, and the rest with counts for reverse stranded library
counts_simple <- counts %>% 
  dplyr::select(Gene_ID = V1, UI92 = V4, UI93 = V8, UI96 = V12, N92 = V16, N93 = V20, WT96 = V24, WT91 = V28, WT94 = V32, N95 = V36)

filter <- apply(dplyr::select(counts_simple,-Gene_ID),1,function(x) mean(x)>5)
counts_simple <- counts_simple [filter,] %>% 
  mutate(Gene_ID = str_remove(Gene_ID, "(gene:)|(transcript:)"))
  
#write.table(counts_simple,file=here::here(str_c(res_path,"tables/only_reverse_strand_counts_cleaned.txt")),sep = "\t", row.names = F)
counts_simple <- counts_simple [,str_detect(colnames(counts_simple),"UI", negate = T)]
```

Visualize EscN counts per sample:
The EscN gene is: E2348C_3948
```{r escn-counts, eval=FALSE}
escn_counts <- counts_simple %>% 
  filter(Gene_ID == "E2348C_3948") %>% 
  pivot_longer(-Gene_ID, names_to = "samples", values_to = "numbers") %>% 
  mutate(time = if_else(str_detect(samples,"UI"), 
                        0, 
                        as.numeric(str_remove(str_extract(samples, "[:digit:]+"), "^[:digit:]"))),
         strain = if_else(str_detect(samples,"WT"), str_c("bold(WT)"),str_c("bold(Delta)*bold(EscN)"))) %>% 
  ggplot() + 
  geom_point(aes(x=fct_reorder(samples,time), y = numbers), size = 3) +
  labs(y = "counts", title = "counts for EscN gene", x = element_blank()) +
  facet_wrap(~strain, ncol = 1, scales = "free", labeller = label_parsed) +
  theme(axis.text.x = element_text(angle = 75, vjust = 0.6))
escn_counts_toscale <- escn_counts + facet_wrap(~strain, scales = "free_x" ,ncol = 1, labeller = label_parsed)

#ggsave(here::here(str_c(res_path,"raw counts for escN.png")),plot = escn_counts,width = 6, height = 8, dpi = 1080)
#ggsave(here::here(str_c(res_path,"raw counts for escN_toscale.png")),plot = escn_counts_toscale, width = 6, height = 8, dpi = 1080)
```

Visualize mapping stats
```{r vis-align-stats, fig.width=8, fig.height=5.5}
#Visualize alignment statistics
counts_stats <- counts_simple %>% 
  dplyr::slice(1:4) %>% 
  pivot_longer(-Gene_ID, values_to = "numbers", names_to = "mapping")
mapped <-  counts_simple %>%
  select(-Gene_ID) %>%
  summarise(across(everything(), sum)) %>% 
  pivot_longer(everything(),values_to = "numbers", names_to = "mapping") %>% 
  mutate(Gene_ID = "Mapped") %>% 
  bind_rows(counts_stats) %>% 
  group_by(mapping) %>% 
  mutate(rel_numbers = calc_relative(numbers)) %>% 
  mutate(Gene_ID = fct_relevel(str_to_title(str_replace(Gene_ID, "N_","")), "Mapped")) %>% 
  mutate(time = if_else(str_detect(mapping,"UI"), 
                        0, 
                        as.numeric(str_remove(str_extract(mapping, "[:digit:]+"), "^[:digit:]"))),
         strain = if_else(str_detect(mapping,"WT"), str_c("bold(WT)"),str_c("bold(Delta)*bold(EscN)")))

#Raw counts stats
raw_count_plot <- ggplot(mapped, aes(x=fct_reorder(mapping,time), y=numbers, fill = Gene_ID)) +
  geom_bar(stat = "identity") + scale_fill_carto_d(palette = discrete_pal_choice) +
  labs(x = "", y = "Raw counts") +
  theme(axis.text.x = element_text(angle = 75, vjust = 0.75, hjust = 0.6)) + 
  guides(fill = guide_legend(title = "Mapping Status")) +
  facet_wrap(~strain, scales = "free", labeller = label_parsed)
#Relative count stats
rel_count_plot <- ggplot(mapped, aes(x=fct_reorder(mapping,time), y=rel_numbers, fill = Gene_ID)) +
  geom_bar(stat = "identity") + scale_fill_carto_d(palette = discrete_pal_choice) +
  labs(x = "", y = "Proportion of counts") +
  theme(axis.text.x = element_text(angle = 75, vjust = 0.75, hjust = 0.6),
        legend.title = element_text()) + 
  guides(fill = guide_legend(title = "Mapping Status")) +
  facet_wrap(~strain, scales = "free", labeller = label_parsed)

#pdf(file = here::here(str_c(res_path,"mapping stats.pdf")), width = 8, height = 5.5)
raw_count_plot
rel_count_plot
#dev.off()
```

Calculate statistics of types of transcripts mapped

```{r map_by_type, fig.width=8, fig.height=5}
#Prepare gene annotation from the gff3 file
geneids <- read_delim(here::here(str_c(data_path,"EPEC_annot.rel-41.gff3")), 
       delim = "\t", escape_double = FALSE, 
       col_names = FALSE, trim_ws = TRUE, skip = 11) 
annot <- geneids %>% 
  filter(X3 == "gene" | X3 == "pseudogene" | X3 == "rRNA_gene" | 
           X3 == "tRNA_gene" | X3 == "ncRNA_gene") %>% 
  filter(str_detect(X9,"ID=gene")) %>% 
  select(X9) %>% 
  separate(X9, into = c("ID", "Name", "Biotype", "Description", "Geneid"), extra = "drop", sep = ";") %>% 
  mutate(ID = str_remove(ID, "ID=gene:"),
         true_name = case_when(
           str_detect(Name, "Name") ~ str_remove(Name, "Name="),
           str_detect(Name, "biotype") ~ ID
           ), true_biotype = case_when(
             str_detect(Name, "biotype") ~ str_remove(Name, "biotype="),
             str_detect(Biotype, "biotype") ~ str_remove(Biotype, "biotype=")
           )) %>% 
  mutate(true_name = if_else(duplicated(true_name), ID, true_name))
c_type <- counts_simple %>% 
  dplyr::slice(-1:-4) %>%
  left_join(dplyr::select(annot, ID, true_biotype), by = c("Gene_ID" = "ID")) %>% 
  dplyr::select(-Gene_ID) %>%
  rename_with(function(x) "Type",last_col()) %>% 
  group_by(Type) %>% 
  summarise(across(everything(),sum)) %>% 
  reshape2::melt() %>% 
  group_by(variable) %>% 
  mutate(rel_numbers = calc_relative(value)) %>% 
  mutate(time = if_else(str_detect(variable,"UI"), 
                        0, 
                        as.numeric(str_remove(str_extract(variable, "[:digit:]+"), "^[:digit:]"))),
         strain = if_else(str_detect(variable,"WT"), str_c("bold(WT)"),str_c("bold(Delta)*bold(EscN)")))
c_type_no_mrna <- c_type %>% 
  filter(Type != "protein_coding") %>% 
   group_by(variable) %>% 
  mutate(rel_numbers = calc_relative(value))

rel_type_plot <- ggplot(c_type, aes(x=fct_reorder(variable,time), y=rel_numbers, fill = fct_reorder(Type,rel_numbers, .desc = T))) +
  geom_bar(stat = "identity") + scale_fill_carto_d(palette = discrete_pal_choice) +
  labs(x = "", y = "Proportion of genes", fill = "Gene type") +
  theme(axis.text.x = element_text(angle = 75, vjust = 0.75, hjust = 0.6)) +
  facet_wrap(~strain, scales = "free", labeller = label_parsed)
rel_type_plot_no_mrna <- ggplot(c_type_no_mrna, 
                                aes(x=fct_reorder(variable,time), y=rel_numbers, fill = fct_reorder(Type,rel_numbers, .desc = T))) +
  geom_bar(stat = "identity") + scale_fill_carto_d(palette = discrete_pal_choice) +
  labs(x = "", y = "Proportion of genes", fill = "Gene type") +
  theme(axis.text.x = element_text(angle = 75, vjust = 0.75, hjust = 0.6)) +
  facet_wrap(~strain, scales = "free", labeller = label_parsed)
#pdf(file = here::here(str_c(res_path,"mapping stats by gene type.pdf")), width = 8, height = 5)
rel_type_plot 
rel_type_plot_no_mrna
#dev.off()
```
Apply EDAseq normalization to the data

```{r edaseq}
c_mat <- counts_simple %>% 
                     dplyr::select(-1) %>% 
                     dplyr::slice(-1:-4) %>% 
                     as.matrix()
rownames(c_mat) <- counts_simple$Gene_ID [-1:-4]
pData <- data.frame(genotype=vector(mode = "logical", length = ncol(c_mat)),
                    timepoint = vector(mode = "logical", length = ncol(c_mat)),
                    samples = colnames(c_mat),
                    row.names = colnames(c_mat))
pData <- pData %>% 
  mutate(genotype = case_when(
    str_detect(samples, "WT") ~ "WT",
    str_detect(samples, "N") ~ "N"
  ), timepoint = "9") %>% 
  dplyr::select(-samples)

data <- newSeqExpressionSet(counts=c_mat,
                            phenoData=pData)
#Normalize the data next
dataNorm <- betweenLaneNormalization(data, which="full") 
#Plot the counts 
#pdf(here::here(str_c(res_path,"Normalization effect on the library.pdf")), width = 8, height = 6.3)
boxplot(data, main = "Unnormalized counts", col = "dodgerblue3")
boxplot(dataNorm, main = "Normalized counts", col = "dodgerblue3")
#dev.off()
#For DE we will create this analysis with offset values
dataOffset <- betweenLaneNormalization(data,
                                       which="full",offset=TRUE)
```

Next step is to use normalized counts in the DESEq2 analysis of differential expression, have to use RUV-normalized library (same as from human reads - use human weights)
```{r deseq}
#Prepare the DESEq2 object and apply EDASeq normalization factors
pData <- read.table(here::here("long_infection_human_reads/long_RNA_library/results/final clean figures/tables/RUVs meta and weights.txt"))
pData <- pData %>% 
  filter(genotype != "UI")
dds <- DESeqDataSetFromMatrix(countData = counts(data),
                              colData = pData,
                              design = ~ W_1 + W_2 + group)
dds$group <- relevel(dds$group, ref= "N9")

#Perform the DESEq2 analysis
dds <- DESeq(dds)
rld <- rlog(dds)

normal_PCA <- plotPCA(rld, returnData = T, intgroup = "group")
#Plot the PCA graphs of the normalized counts
#png(here::here(str_c(res_path,"PCA plot of normalized counts.png")), width = 8, height = 6, units = "in", res = 1080)
ggplot(data = normal_PCA, aes(shape = pData$genotype, color = pData$genotype)) +
  scale_color_manual(labels = c("N" = bquote(Delta*"EscN EPEC"),
                                "WT" = "Wild-type EPEC", "UI" = "Uninfected"),
                     values = c("WT" = carto_pal(12,discrete_pal_choice) [2], 
                                "N" = carto_pal(12,discrete_pal_choice) [1])) +
  geom_point(mapping = aes(x = PC1, y = PC2), size = 5) +
  labs(title = "RUVs corrected PCA plot", shape = "Infection", color = "Infection",
       x = "PC1: 40% variance", y = "PC2: 33% variance") +
  scale_shape_manual(labels = c("N" = bquote(Delta*"EscN EPEC"),
                                "WT" = "Wild-type EPEC"),
                     values = c( "WT" = 16, "N" = 17)) +
  theme(legend.position = "bottom", legend.title = element_text())
#dev.off()
```
Identify differentially expressed genes
```{r deseq-res}
resWTvsN <- results(dds, contrast = c("group","WT9", "N9"))
summary(resWTvsN)

time_res_annot <- resWTvsN %>% 
  as_tibble(rownames = "Row.names") %>% 
  left_join(dplyr::select(annot,ID,true_name,true_biotype), by = c("Row.names" = "ID"))
#write.table(time_res_annot, here::here(str_c(res_path, "tables/RUV+EDAseq_normalized results comparing  WT and EscN infection.csv")),
 #          sep = ",", row.names = F)
```

Analyze loadings of the principal components in the data
```{r pcatools, fig.width=8, fig.height=6.3}
#Annotate the gene id to more meaningful gene names
cnts <- assay(rld) 
cnts_annot <- cnts %>% 
  as_tibble(rownames = "ID") %>% 
  select(ID) %>% 
  left_join(dplyr::select(annot,ID,true_name))
#Confirm the order of rows is the same and can move onto symbol mapping
all(rownames(cnts) == cnts_annot$ID)
rownames(cnts) <- cnts_annot$true_name
p <- PCAtools::pca(cnts,colData(dds), removeVar = 0.1)
p_coord_meta <- p$rotated %>% 
  merge(as.data.frame(colData(rld)), by=0) 
#6 PCs explain 100% of variance, so just focus on those for linear regression
pc_to_choose <- 6
#Create the lists to store information on the linear model performance
fit_list <- set_names(vector(mode = "list", length = pc_to_choose),
                              nm = str_c("PC",1:pc_to_choose))
signi_list <- set_names(vector(mode = "list", length = pc_to_choose),
                              nm = str_c("PC",1:pc_to_choose))
#Generally, we are testing to see if metadata dictate PC coordinates
for (PC in seq_along(fit_list)) {
  fit_list [[PC]] <- set_names(vector(mode = "list", length = 1),
                               nm = c("group"))
  signi_list [[PC]] <- set_names(vector(mode = "list", length = 1),
                                 nm = c("group"))
  for (metavar in c("group")) {
    frm <- as.formula(str_c("PC",PC, " ~ ", metavar))
    fit_list [[PC]] [[metavar]] <- lm(frm, data = p_coord_meta)
    sum_of_fit <- summary(fit_list [[PC]] [[metavar]])
    signi_list [[PC]] [[metavar]] <- sum_of_fit$coefficients %>% 
      as.data.frame() %>% 
      mutate(R_squared = sum_of_fit$r.squared,
             PC = str_c("PC",PC),
             metavar = metavar) %>% 
      rownames_to_column(var = "coef")
  }
}
#Summarise liner model performance and plot the results
signi_list_reduced <- signi_list %>% 
  map_depth(1,reduce,bind_rows) %>% 
  reduce(bind_rows) %>% 
  filter(coef != "(Intercept)") %>% 
  dplyr::rename(p = `Pr(>|t|)`) %>%  
  mutate(signi = if_else(p<0.05, "yes","no"))
#Plot the results of regression
ggplot(signi_list_reduced) +
  geom_tile(aes(y=coef,x=PC, fill = p)) +
  geom_text(data = filter(signi_list_reduced, signi == "yes"), aes(y=coef,x=PC), 
            label = "*", color = "white", size = 7, nudge_y = -0.02) +
  labs(x = element_blank(), y = element_blank(), 
       title = "Linear regression analysis\nidentifying relationships between metadata and PC") +
  scale_y_discrete(labels = c(groupWT9 = "Group")) +
  scale_fill_carto_c(palette = "BluYl", direction = -1, name = "p-value") +
  theme_minimal(base_size = 16) +
  theme(panel.border = element_rect(fill = NA, color = "black"),
        axis.ticks.x = element_line(color = "black"),
        axis.ticks.y = element_line(color = "black"),
        panel.grid.major = element_blank(),
        axis.text = element_text(color = "black"),
        axis.text.x = element_text(angle = 45, vjust = 0.6),
        title = element_text(size = 12),
        legend.title = element_text(size = 19))
#ggsave(here::here(str_c(res_path,"Linear regression of metadata and PCA with respect to RUV.png")),width = 8, height = 6.66, dpi = 1080)

signi_list_rsquare <- signi_list_reduced %>% 
  distinct(metavar, PC, .keep_all = T) %>% 
  mutate(metavar = str_to_title(metavar))

ggplot(signi_list_rsquare) +
  geom_tile(aes(y=metavar,x=PC, fill = R_squared)) +
  geom_text(data = filter(signi_list_rsquare, signi == "yes"), aes(y=metavar,x=PC), 
            label = "*", color = "white", size = 7, nudge_y = -0.02) +
  labs(x = element_blank(), y = element_blank(), 
       title = "Linear regression analysis\nidentifying relationships between metadata and PC") +
  scale_y_discrete(labels = c(groupWT9 = "Group")) +
  scale_fill_carto_c(palette = "BluYl", direction = 1, name = bquote("R"^2*"-value")) +
  theme_minimal(base_size = 16) +
  theme(panel.border = element_rect(fill = NA, color = "black"),
        axis.ticks.x = element_line(color = "black"),
        axis.ticks.y = element_line(color = "black"),
        panel.grid.major = element_blank(),
        axis.text = element_text(color = "black"),
        axis.text.x = element_text(angle = 45, vjust = 0.6),
        title = element_text(size = 12),
        legend.title = element_text(size = 19))
#ggsave(here::here(str_c(res_path,"Linear regression of metadata and PCA with respect to RUV R-square.png")),width = 6, height = 4, dpi = 1080)
```

Make volcano plots of differentially expressed genes
```{r volcano}
#shrink results
resWTvsNlfc <- lfcShrink(dds, coef="group_WT9_vs_N9", type="apeglm", res = resWTvsN)
all(rownames(resWTvsNlfc) == cnts_annot$ID)
#Put into a list
results_list <- list(resWTvsNlfc)
#Prepare the results list for plotting
res_df_list <- results_list %>% 
  map(as.data.frame) %>% 
  map(rownames_to_column, var = "gene") %>% 
  map(mutate, signi = if_else(padj < 0.05 & abs(log2FoldChange) >= 0.5, "yes","no"))
#Create the function for making a nice volcano plot
volcano_ggplot <- function(res_df, title = "", to_label = F, n_lab = 10) {
  p_empty <- ggplot(res_df, aes(x = log2FoldChange, y = -log10(padj), fill = signi, color = signi)) +
    geom_hline(yintercept = -log10(0.05), lty = 2, lwd = 0.8, color = "grey30") +
    geom_vline(xintercept = -0.5, lty = 2, lwd = 0.8, color = "grey30") +
    geom_vline(xintercept = 0.5, lty = 2, lwd = 0.8, color = "grey30") +
    geom_point(size = 4, shape = 21, alpha = 0.7) +
    scale_color_manual(values = c("darkgrey", carto_pal(7,diverg_pal_choice) [7])) +
    scale_fill_manual(values = c("darkgrey", carto_pal(7,diverg_pal_choice) [7])) +
    guides(color = 'none', fill = 'none') +
    labs(x = bquote(~Log[2] ~ "fold change"),
         y = bquote(~-Log[10] ~ italic(P)),
         title = title) +
    theme_prism(base_size = 24) +
    theme(title = element_text(size = 10),
          axis.title = element_text(size = 24))
  if(to_label) {
    res_df_top <- res_df %>% 
      filter(signi == "yes") %>% 
      arrange(desc(abs(log2FoldChange))) %>% 
      slice_head(n=n_lab)
    p_labelled <- p_empty + 
      geom_label_repel(data = res_df_top, aes(x = log2FoldChange, y = -log10(padj), label = gene),
                       size = 4, max.overlaps = Inf, color = "black", fill = "white")
    return(p_labelled)
  } else {
    return(p_empty)
  }
}
#Print the volcano plots - each should get its own png file
volcano_list <- map2(res_df_list, 
                     c("WT vs T3SS mutant"),
                     volcano_ggplot)
#walk2(volcano_list, c("WT vs T3SS mutant"),
 #     ~ggsave(here::here(str_c(res_path,"Volcano_plot of ",.y,".png")),plot = .x), width = 8, height = 6, dpi = 1080)

#pdf(here::here(str_c(res_path,"MA plots.pdf")), width = 8, height = 6.3)
plotMA(resWTvsN, main = "Results without shrinking")
plotMA(resWTvsNlfc, main = "Results after apeglm shrinking")
#dev.off()
```
Apply clusterprofiler to differentially expressed data
EPEC code in KEGG is ecg

For GSEA, use all genes, not just DE - https://hbctraining.github.io/Training-modules/DGE-functional-analysis/lessons/functional_analysis_2019.html

```{r clusterprofiler}
#If KEGG is giving troubles with clusterprofiler run this, can switch to wget instead of auto:
#library(R.utils)
R.utils::setOption("clusterProfiler.download.method","auto")

#Prep a list of each gene lists
gl_all_df_list <- list(resWTvsNlfc) %>% 
  set_names("WTvsN") %>% 
  map(as_tibble, rownames = "ID") 
gl_df_list <- gl_all_df_list %>% 
  map(~filter(.x,padj < 0.05, abs(log2FoldChange) > 0.5)) %>% 
  map(~arrange(.x,desc(log2FoldChange)))
#Get the genelists prepared
gl_gene_list <- gl_df_list %>% 
  map(~set_names(pull(.x,var = "log2FoldChange"), pull(.x, var = "ID")))
gse_gene_list <- gl_all_df_list %>% 
  map(~arrange(.x,desc(log2FoldChange))) %>% 
  map(~set_names(pull(.x,var = "log2FoldChange"), pull(.x, var = "ID")))
#Run the ora and gsea analyses
ora_list <- gl_gene_list %>% 
  map(~enrichKEGG(gene = names(.x),
                  organism     = 'ecg',
                  universe = rownames(resWTvsNlfc),
                  pvalueCutoff = 0.05,
                  qvalueCutoff = 0.05))
gse_list <- gse_gene_list %>% 
  map(~gseKEGG(geneList     = .x,
               organism     = 'ecg',
               pvalueCutoff = 0.05,
               verbose      = F))


#Also divide genes by up and down regulation
gl_updown_list <- gl_gene_list
for (comp in seq_along(gl_gene_list)) {
  genes_vector <- gl_gene_list [[comp]]
  gl_updown_list [[comp]] <- vector(mode = "list", length = 2) %>% 
    set_names(c("up","down"))
  gl_updown_list [[comp]] [[1]] <- genes_vector [genes_vector > 0]
  gl_updown_list [[comp]] [[2]] <- genes_vector [genes_vector < 0]
}
#Repeat ora and gse analyses
ora_updown_list <- gl_updown_list %>% 
  map_depth(2,~enrichKEGG(gene = names(.x),
                  organism     = 'ecg',
                  universe = rownames(resWTvsNlfc),
                  pvalueCutoff = 0.05,
                  qvalueCutoff = 0.05))
ora_updown_df <- ora_updown_list %>% 
  map_depth(2,as.data.frame) %>% 
  map(~map2(.x, c("Up","Down"), 
            ~mutate(.x, Direction = .y))) %>% 
  map(reduce, bind_rows) %>% 
  map(mutate, geneRatio = as.numeric(DOSE::parse_ratio(GeneRatio)))
```


```{r clusterprofiler-plot, eval=FALSE, fig.width=7, fig.height=5}
#Visualize all the results
#pdf(here::here(str_c(res_path,"Functional profiling plots.pdf")), width = 7, height = 5)
walk2(ora_list, names(ora_list),
      ~print(dotplot(.x) + scale_color_carto_c(palette = cont_pal_choice, direction = -1) +
               labs(title = str_c("whole ORA ",.y))))
walk2(keep(gse_list, ~nrow(.)>0), names(keep(gse_list, ~nrow(.)>0)),
      ~print(dotplot(.x, x = "NES") + scale_color_carto_c(palette = cont_pal_choice, direction = -1) +
               labs(title = str_c("GSEA ",.y))))

walk2(ora_updown_df, names(ora_updown_df),
      ~print(ggplot(.x, 
                    aes(x=geneRatio, y = fct_reorder(Description, geneRatio),
                        color = p.adjust, fill = p.adjust, size = Count, shape = Direction)) +
               geom_point(color = "black") +
               scale_shape_manual(values = c("Up" = 24, "Down" = 25)) +
               scale_size_continuous(range = c(4,8)) +
               scale_color_carto_c(palette = cont_pal_choice, direction = -1) +
               scale_fill_carto_c(palette = cont_pal_choice, direction = -1) +
               theme_minimal(base_size = 12) +
               guides(shape = guide_legend(override.aes = list(size = 4.5, fill = carto_pal(2,cont_pal_choice) [2]))) +
               labs(x="GeneRatio", y=element_blank(), title = .y) +
               theme(panel.border = element_rect(fill = NA, color = "black"),
                     axis.text = element_text(color = "black"))))

#dev.off()
#print out all the clusterprofiler results
#walk2(c(ora_list,keep(gse_list, ~nrow(.)>0), ora_updown_df), 
 #     c(str_c("whole_ORA",names(ora_list)), str_c("GSEA_", names(keep(gse_list, ~nrow(.)>0))), names(ora_updown_df)),
  #    ~write_csv(as.data.frame(.x), file = here::here(str_c(res_path,"tables/",.y,".csv"))))
```


